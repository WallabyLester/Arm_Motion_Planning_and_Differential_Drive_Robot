#!/usr/bin/env python
"""


PUBLISHERS: 
    

SUBSCRIBERS:
    

SERVICES:

PARAMETERS:

"""

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
from geometry_msgs.msg import TransformStamped, Twist, Vector3, PoseStamped, Quaternion
from tf_conversions import transformations
from math import pi, fabs, cos, sqrt
from std_msgs.msg import String
from moveit_commander.conversions import pose_to_list, list_to_pose
from std_srvs.srv import Empty, EmptyResponse
from arm_move.srv import Step, Follow, FollowResponse


class Mover():
    """
    """
    def __init__(self):
        super(Mover, self).__init__()

        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()
        group_name = "interbotix_arm"
        self.move_group = moveit_commander.MoveGroupCommander(group_name)
        self.gripper_group = moveit_commander.MoveGroupCommander("interbotix_gripper")
        self.planning_frame = self.move_group.get_planning_frame()
        self.waypoints = rospy.get_param("/waypoints")
        self.clear_waypoints = rospy.get_param("~clear_waypoints")
        self.reset = rospy.Service("reset", Empty, self.reset_callback)
        self.step = rospy.Service("step", Step, self.step_callback)
        self.follow = rospy.Service("follow", Follow, self.follow_callback)

        self.add_table()
    
    def wait_for_state_update(self, box_name, box_is_known=False, box_is_attached=False, timeout=4):
        """ Description

        More description

        Args: 
            box_is_known (bool) : if box is in get_known_object_names()
            box_is_attached (bool) : if box is in get_attached_objects()
            timeout (int) : time limit
        
        """
        start = rospy.get_time()
        seconds = rospy.get_time()

        while (seconds - start < timeout) and not rospy.is_shutdown():
            # Test if the box is in attached objects
            attached_objects = self.scene.get_attached_objects([box_name])
            is_attached = len(attached_objects.keys()) > 0

            # Test if the box is in the scene.
            # Note that attaching the box will remove it from known_objects
            is_known = box_name in self.scene.get_known_object_names()

            # Test if we are in the expected state
            if (box_is_attached == is_attached) and (box_is_known == is_known):
                return True

            # Sleep so that we give other threads time on the processor
            rospy.sleep(0.1)
            seconds = rospy.get_time()

        # If we exited the while loop without returning then we timed out
        return False

    def add_table(self):
        table_pose = PoseStamped()
        table_pose.header.frame_id = "world"
        table_pose.pose.position.x = 0.25
        table_pose.pose.position.y = 0.0
        table_pose.pose.position.z = -0.025
        table_pose.pose.orientation.w = 1.0
        table_name = "table"
        while not self.wait_for_state_update(table_name, box_is_known=True):
            self.scene.add_box(table_name, table_pose, size=(1.0, 0.62, 0.05))

    def add_realsense(self):
        box_pose = PoseStamped()
        box_pose.header.frame_id = "world"
        box_pose.pose.position.x = 0.12
        box_pose.pose.position.y = 0.0
        box_pose.pose.position.z = 0.025
        box_pose.pose.orientation.w = 1.0
        box_name = "realsense_box"
        while not self.wait_for_state_update(box_name, box_is_known=True):
            self.scene.add_box(box_name, box_pose, size=(0.09, 0.14, 0.05))

    def reset_callback(self, empty):
        self.add_realsense()
        self.move_group.set_named_target("Home")
        self.move_group.go()
        self.move_group.stop()
        self.move_group.clear_pose_targets()

        if self.clear_waypoints:
            self.waypoints = []
        
        return EmptyResponse()

    def step_callback(self, data):
        pose = data.pose
        gripper = data.gripper

        self.move_group.set_pose_target(pose)
        success_flag, trajectory_message, planning_time, error_code = self.move_group.plan()
        if not success_flag:
            return error_code

        self.move_group.execute(trajectory_message, wait=True)
        self.move_group.stop()
        self.move_group.clear_pose_targets()

        if gripper:
            self.gripper_group.set_named_target("Closed")
        else:
            self.gripper_group.set_named_target("Open")
        self.gripper_group.go()
        self.gripper_group.stop()
        self.gripper_group.clear_pose_targets()

        self.waypoints.append([pose_to_list(pose), gripper])
        rospy.set_param("/waypoints", self.waypoints)

        return error_code

    def follow_callback(self, data):
        waypoint = self.waypoints[0][0]
        # waypoint = waypoint[0]
        pose_list = list_to_pose(waypoint[0:6])
        gripper = waypoint[7]
        print(pose_list)
        print(gripper)
        # for waypoint in self.waypoints:
        #     pose = waypoint[0:6]
        #     gripper = waypoint[7]
        #     pose_list = list_to_pose(pose)
        #     self.move_group.set_pose_target(pose_list)
        #     success_flag, trajectory_message, planning_time, error_code = self.move_group.plan()
        #     self.move_group.execute(trajectory_message, wait=True)
        #     self.move_group.stop()
        #     self.move_group.clear_pose_targets()

        #     if gripper:
        #         self.gripper_group.set_named_target("Closed")
        #     else:
        #         self.gripper_group.set_named_target("Open")
        #     self.gripper_group.go()
        #     self.gripper_group.stop()
        #     self.gripper_group.clear_pose_targets()

        # if data.repeat:
        #     self.follow_callback()
        
        # return error_code
        

def main():
    moveit_commander.roscpp_initialize(sys.argv)
    rospy.init_node("mover", anonymous=True, log_level=rospy.DEBUG)
    Mover()
    rospy.spin()

if __name__=="__main__":
    try:
        main()
    except rospy.ROSInterruptException:
        pass