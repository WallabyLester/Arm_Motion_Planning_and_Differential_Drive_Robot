#!/usr/bin/env python
"""


PUBLISHERS: 
    

SUBSCRIBERS:
    

SERVICES:

PARAMETERS:

"""

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
from geometry_msgs.msg import TransformStamped, Twist, Vector3, PoseStamped, Quaternion
from tf_conversions import transformations
from math import pi, fabs, cos, sqrt
from std_msgs.msg import String
from moveit_commander.conversions import pose_to_list
from std_srvs.srv import Empty, EmptyResponse


class Mover():
    """
    """
    def __init__(self):
        super(Mover, self).__init__()

        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()
        group_name = "interbotix_arm"
        self.move_group = moveit_commander.MoveGroupCommander(group_name)
        self.planning_frame = self.move_group.get_planning_frame()
        # self.waypoints = rospy.get_param("/waypoints")
        self.reset = rospy.Service("reset", Empty, self.reset_callback)


        self.add_table()

        # display_trajectory_publisher = rospy.Publisher(
        #     "/move_group/display_planned_path",
        #     moveit_msgs.msg.DisplayTrajectory,
        #     queue_size=20,)
        
        # self.display_trajectory_publisher = display_trajectory_publisher
        
        # self.eef_link = eef_link
        # self.group_names = group_names
    
    def wait_for_state_update(self, box_name, box_is_known=False, box_is_attached=False, timeout=4):
        """ Description

        More description

        Args: 
            box_is_known (bool) : if box is in get_known_object_names()
            box_is_attached (bool) : if box is in get_attached_objects()
            timeout (int) : time limit
        
        """
        start = rospy.get_time()
        seconds = rospy.get_time()

        while (seconds - start < timeout) and not rospy.is_shutdown():
            # Test if the box is in attached objects
            attached_objects = self.scene.get_attached_objects([box_name])
            is_attached = len(attached_objects.keys()) > 0

            # Test if the box is in the scene.
            # Note that attaching the box will remove it from known_objects
            is_known = box_name in self.scene.get_known_object_names()

            # Test if we are in the expected state
            if (box_is_attached == is_attached) and (box_is_known == is_known):
                return True

            # Sleep so that we give other threads time on the processor
            rospy.sleep(0.1)
            seconds = rospy.get_time()

        # If we exited the while loop without returning then we timed out
        return False

    def add_table(self):
        table_pose = PoseStamped()
        table_pose.header.frame_id = "world"
        table_pose.pose.position.x = 0.25
        table_pose.pose.position.y = 0.0
        table_pose.pose.position.z = -0.025
        table_pose.pose.orientation.w = 1.0
        table_name = "table"
        while not self.wait_for_state_update(table_name, box_is_known=True):
            self.scene.add_box(table_name, table_pose, size=(1.0, 0.62, 0.05))

    def add_realsense(self):
        box_pose = PoseStamped()
        box_pose.header.frame_id = "world"
        box_pose.pose.position.x = 0.20
        box_pose.pose.position.y = 0.0
        box_pose.pose.position.z = 0.025
        box_pose.pose.orientation.w = 1.0
        box_name = "realsense_box"
        while not self.wait_for_state_update(box_name, box_is_known=True):
            self.scene.add_box(box_name, box_pose, size=(0.14, 0.09, 0.05))

    def reset_callback(self, empty):
        self.add_realsense()
        self.move_group.set_named_target("Home")
        self.move_group.go()
        self.move_group.stop()
        self.move_group.clear_pose_targets()
        
        return EmptyResponse()

def main():
    moveit_commander.roscpp_initialize(sys.argv)
    rospy.init_node("mover", anonymous=True)
    Mover()
    rospy.spin()

if __name__=="__main__":
    try:
        main()
    except rospy.ROSInterruptException:
        pass